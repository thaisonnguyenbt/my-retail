package my.retail.core.listeners;

import static my.retail.core.constants.ApplicationConstants.ASSET_UPDATE_PATH;
import static my.retail.core.constants.ApplicationConstants.JCR_PATH;
import static my.retail.core.constants.ApplicationConstants.ORIGINAL_RENDITION_RELATIVE_PATH;
import static my.retail.core.constants.ApplicationConstants.THUMBNAIL_WORKFLOW_PATH;
import static my.retail.core.constants.ExceptionConstants.ERROR_EXEC_WORKFLOW;
import static my.retail.core.constants.ExceptionConstants.ERROR_LOGIN;
import static my.retail.core.constants.ExceptionConstants.ERROR_REPOSITORY;

import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.Workspace;
import javax.jcr.observation.Event;
import javax.jcr.observation.EventIterator;
import javax.jcr.observation.EventListener;
import javax.jcr.observation.ObservationManager;

import org.apache.felix.scr.annotations.Activate;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Deactivate;
import org.apache.felix.scr.annotations.Reference;
import org.apache.sling.api.resource.LoginException;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.apache.sling.jcr.api.SlingRepository;
import org.osgi.service.component.ComponentContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.day.cq.workflow.WorkflowException;
import com.day.cq.workflow.WorkflowService;
import com.day.cq.workflow.WorkflowSession;
import com.day.cq.workflow.exec.WorkflowData;
import com.day.cq.workflow.model.WorkflowModel;

/**
 * Adds an event listener to run the ArgilDX Watermark Workflow on node move
 * under '/content/dam/images'
 * 
 * @author ArgilDX
 */
@Component
public class ThumbnailNodeMovedListener implements EventListener {

	/**
	 * The Logger
	 */
	Logger log = LoggerFactory.getLogger(ThumbnailNodeMovedListener.class);

	/**
	 * For creating the appropriate session for the event listener
	 */
	@Reference
	SlingRepository repository;

	/**
	 * For invoking the Workflow
	 */
	@Reference
	WorkflowService workflowService;

	/**
	 * The Resource Resolver Factory Service
	 */
	@Reference
	ResourceResolverFactory resolverFactory;

	/**
	 * The Resource Resolver object
	 */
	ResourceResolver resolver;

	/**
	 * The session object
	 */
	Session session;

	/**
	 * Method run on component activation. Executed once in the component's life
	 * cycle.
	 * 
	 * @param ctx
	 *            The component context object
	 */
    @Activate
    @SuppressWarnings("deprecation")
	protected void activate(ComponentContext ctx) {
		try {

			// Log in to the repository as an administrative user and get the resulting
			// session. The event listener uses this session to execute its logic. NB: This
			// is only for demonstrative purposes. In a project, you would create a service
			// user and use the loginService(...) method instead.
			session = repository.loginAdministrative(null);

			if (session == null) {
				return;
			}

			// The workspace is used to get the ObservationManager
			Workspace workspace = session.getWorkspace();

			if (workspace == null) {
				return;
			}

			// The ObservationManager allows us to add and remove Event Listeners
			ObservationManager observationManager = workspace.getObservationManager();

			// Building the parameters for adding the event listener

			// Whether the subfolders of the given path should also be watched
			boolean isDeep = true;

			// Only events whose associated node has one of the UUIDs in this list will be
			// received. If this parameter is null then no UUID-related restriction is
			// placed on events received.
			String[] uuid = null;

			// Only events whose associated node has one of the node types (or a subtype of
			// one of the node types) in this list will be received. If this parameter is
			// null then no node type-related restriction is placed on events received.
			String[] nodeTypeName = null;

			// If noLocal is true, then events generated by the session through which the
			// listener was registered are ignored. Otherwise, they are not ignored.
			boolean noLocal = true;

			// Registering the event listener
            observationManager.addEventListener(this, Event.NODE_MOVED, ASSET_UPDATE_PATH, isDeep, uuid, nodeTypeName, noLocal);
            observationManager.addEventListener(this, Event.NODE_ADDED, ASSET_UPDATE_PATH, isDeep, uuid, nodeTypeName, noLocal);
            observationManager.addEventListener(this, Event.NODE_REMOVED, ASSET_UPDATE_PATH, isDeep, uuid, nodeTypeName, noLocal);
            observationManager.addEventListener(this, Event.PROPERTY_ADDED, ASSET_UPDATE_PATH, isDeep, uuid, nodeTypeName, noLocal);
            observationManager.addEventListener(this, Event.PROPERTY_CHANGED, ASSET_UPDATE_PATH, isDeep, uuid, nodeTypeName, noLocal);
            observationManager.addEventListener(this, Event.PROPERTY_REMOVED, ASSET_UPDATE_PATH, isDeep, uuid, nodeTypeName, noLocal);

		} catch (javax.jcr.LoginException lEx) {
			log.error(ERROR_LOGIN + lEx.getMessage(), lEx);
		} catch (RepositoryException rEx) {
			log.error(ERROR_REPOSITORY + rEx.getMessage(), rEx);
		}
	}

	/**
	 * Method run on component deactivation. Executed once in the component's life
	 * cycle.
	 * 
	 * @param componentContext
	 *            The component context
	 * @throws RepositoryException
	 */
	@Deactivate
	protected void deactivate(ComponentContext componentContext) throws RepositoryException {

		try {
			if (session == null) {
				return;
			}

			// The workspace is used to get the ObservationManager
			Workspace workspace = session.getWorkspace();

			if (workspace == null) {
				return;
			}

			// The ObservationManager allows us to add and remove Event Listeners
			ObservationManager observationManager = workspace.getObservationManager();

			if (observationManager != null) {
				observationManager.removeEventListener(this);
			}
		} finally {
			if (session != null) {
				session.logout();
				session = null;
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
    @Override
    @SuppressWarnings("deprecation")
	public void onEvent(EventIterator itr) {
		while (itr.hasNext()) {
			Event currentEvent = itr.nextEvent();
			try {
				// This is only for demonstrative purposes. In a project, use a service resource
				// resolver
				resolver = resolverFactory.getAdministrativeResourceResolver(null);

				// Invoke the adaptTo method to create a Session
				Session localSession = resolver.adaptTo(Session.class);

				if (localSession == null) {
					return;
				}

				// Create a workflow session
				WorkflowSession wfSession = workflowService.getWorkflowSession(localSession);

				// Get the workflow model
				WorkflowModel wfModel = wfSession.getModel(THUMBNAIL_WORKFLOW_PATH);

				// Get the Workflow data. The first parameter in the newWorkflowData method is
				// the payloadType. Just a fancy name to let it know what type of workflow it is
				// working with.
				WorkflowData wfData = wfSession.newWorkflowData(JCR_PATH, currentEvent.getPath()+ORIGINAL_RENDITION_RELATIVE_PATH);

				// Start the Workflow.
				wfSession.startWorkflow(wfModel, wfData);

			} catch (WorkflowException wEx) {
				log.error(ERROR_EXEC_WORKFLOW + wEx.getMessage(), wEx);
			} catch (RepositoryException rEx) {
				log.error(ERROR_REPOSITORY + rEx.getMessage(), rEx);
			} catch (LoginException lEx) {
				log.error(ERROR_LOGIN + lEx.getMessage(), lEx);
			} finally {
				if (resolver != null) {
					resolver.close();
					resolver = null;
				}
			}
		}
	}
}
